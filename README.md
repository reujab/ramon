# Ramon

> :warning: This project is a WIP and not yet functional. All configuration is subject to change.

Ramon is a lightweight, versatile server monitoring framework. It runs actions (e.g. sending emails) when certain conditions are met. For example, you can configure Ramon to send an email every time an SSH connection from a new IP address is established. Or send an email when a service goes down. Perhaps you would like daily emails of any 5xx server errors that occurred. Ramon makes this easy.

Ramon's design is heavily inspired by [fail2ban](https://github.com/fail2ban/fail2ban) and [Tasker](https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm).

## Examples

### Setup

```toml
[notify.default]
smtp = "localhost:587"
from = "ramon@{{host}}"
to = "you@{{host}}"
limit = "10/m"
# When a notification is dispatched, wait 10 seconds to see
# if another notification with the same id is dispatched,
# and aggregate them into one notification. If this process
# repeats for longer than 1 minute, send the notification immediately.
aggregate = "10s"
aggregate_timeout = "1m"
notify = "default"

# Aggregate all info notifications, and send them all in
# one email at 8:00AM daily.
[notify.type.info]
aggregate = "0 8 * * *"

# Do not aggregate critical notifications.
[notify.type.critical]
aggregate = 0
```

### SSH

```toml
# Log each login from a new IP
[store]
ssh_ips = []

[monitor.ssh_login]
service = "ssh"
match_log = '^.*\]: Accepted \S+ for (?<user>\S+) from (?<ip>)'
if = { "!ssh_ips" = "{{ip}}" }
push = { ssh_ips = "{{ip}}" }
notify = { type = "critical", title = "New SSH login from {{ip}} to {{user}}@{{host}}" }

# Alternatively, log every login
[monitor.ssh_login]
service = "ssh"
match_log = '^.*\]: Accepted \S+ for (?<user>\S+) from (?<ip>)'
[[monitor.ssh_login.actions]]
if = { ssh_ips = "{{ip}}" }
# We only send these info emails once per day. (See Setup.)
notify = { type = "info", title = "SSH login to {{user}}@{{host}}" }
[[monitor.ssh_login.actions]]
if = { "!ssh_ips" = "{{ip}}" }
push = { ssh_ips = "{{ip}}" }
notify = { type = "critical", title = "New SSH login from {{ip}} to {{user}}@{{host}}" }
```

### System resources

```toml
[monitor.cpu] # Monitor
every = "1s" # Event
if = { cpu = ">90" } # Condition
threshold = "2m" # Condition
notify = { type = "warn", title = "[{{host}}] CPU > 90% for 2m" } # Action
cooldown = "1h" # Condition

[monitor.ram]
every = "1s"
if = { ram = ">90", swap = ">50" }
notify = { type = "warn", title = "[{{host}}] RAM: {{ram}}%, swap: {{swap}}%" }
cooldown = "1h"
```

### Nginx

```toml
[var]
nginx_log = "/var/log/nginx/access.log"

[monitor.nginx_5xx]
log = "{{nginx_log}}"
match_log = '^\S+ \S+ \S+ \[.+\] "(?<path>.*)" (?<code>5\d{2})'
notify = { type = "error", title = "Server error: {{code}} at {{path}}" }

# Report 404s generated by browsers.
# We can determine browsers by seeing if
# they successfully GET a .css file.
[var]
human_ips = []

[monitor.mark_human]
log = "{{nginx_log}}"
match_log = '^(?<ip>\S+) \S+ \S+ \[.+\] ".*\.css" 200'
push = { human_ips = "{{ip}}" }

[monitor.nginx_404]
log = "{{nginx_log}}"
match_log = '^(?<ip>\S+) \S+ \S+ \[.+\] "(?<path>.*)" 404'
if = { human_ips = "{{ip}}" }
notify = { type = "info", title = "404 at {{path}}" }
```

### HTTP

```toml
[monitor.example_endpoint]
every = "5m"
get_fail = "https://example.com/endpoint"
notify = { type = "error", title = "{{url}}: {{err}}" }
```

### systemd

```toml
[monitor.services]
on = [ "service_fail" ]
notify = { type = "error", title = "Service failed: {{service}}" }

[monitor.critical_service]
service = "criticald"
on = [ "service_fail" ]
notify = { type = "critical", title = "Critical daemon failed! Restarting..." }
```

### System integrity

```toml
[monitor.etc_passwd]
watch = "/etc/passwd"
notify = { type = "critical", title = "File changed: /etc/passwd" }

[monitor.ports]
on = [ "port_open" ]
notify = { type = "critical", title = "New port opened: {{port}}" }
```

### Tasks

```toml
# The following three monitors function identically.

[monitor.1]
# ...
exec = 'echo "Cpu: $cpu%"'

[monitor.2]
# ...
exec = ["echo", "Cpu:", "{{cpu}}%"]

[task.print_cpu]
exec = ["echo", "Cpu:", "{{cpu}}%"]
[monitor.3]
# ...
call = "print_cpu"
```

## Specification (WIP)

On startup, Ramon loads [an internal config file] with sane defaults, and then it loads /etc/ramon.d/\*.toml, and finally it loads /etc/ramon.toml. Each succeeding config file overwrites any properties loaded prior.\*

### Monitors

Monitors are configured by creating a table in the `[monitor]` table (e.g. `[monitor.example]`). Each key in a monitor is classified as an event, a condition, or an action. A monitor must have at least one event. When an event is fired, the monitor evaluates each condition, and if they are all true, then the actions are performed. Monitors can share data with each other through variables.

### Events

#### `service`\* string or array of strings

This event is fired every time the specified services output a line to the systemd journal.

##### Local variables

- `service` name of the service

#### `log` glob\* (string), or array\* of globs

This event is fired for every line that is appended to the specified files.

#### `watch`\* glob (string), or array of globs

This event is fired each time the contents of a file change.

##### Local variables

- `file` the path to the file that changed

#### `every`\* duration (string)

This event is fired immediately, and then at the specified interval. A value of `"1ms"` fires every millisecond, `"1s"` every second, `"1m"` minute, `"1h"` hour, `"1d"` day, `"1w"` week, and `"1mo"` fires every month.

```toml
[monitor.timestamp]
every = "1m"
notify = { title = 'The current timestamp is {{ exec("date", "+%s") }}.' }
```

#### `at`\* cron (string)

This event is fired at the specified date and time. Refer to <https://crontab.guru> for help.

#### `on`\* string or array of strings

This key allows the monitor to listen to one or more of the following events:

- `service_fail` is fired when a systemd service fails. Sets `service` to the failing service's name.
- `port_forwarded` is fired when a new port is open on your public IP address. Sets `port` (number) to the opened port.
- `port_closed` is fired when a public port is closed. Sets `port` (number) to the closed port.

### Conditions

Conditions are evaluated sequentially in order of priority. Higher priority (least negative) conditions are evaluated before lower priority conditions. The priority is listed in brackets after the key.

#### `cooldown`\* [-10] duration (string)

This condition is true if actions have not been run within the specified duration.

```toml
[monitor.1]
every = "1s"
cooldown = "1m"
exec = "echo I will never run more than once per minute."
```

#### `match_log` [-20] regex (string) or array of regexes

This condition is true if the line matches the specified regular expressions. This condition only applies to events from `log` or `service`. If this key is an array, all regular expressions must match.

Named capture groups defined in the regular expression will become available as local variables to the following conditions and actions.

#### `ignore_log`\* [-21] regex (string)

This condition is true if the line does not match the specified regular expression. This condition only applies to events from `log` or `service`.

#### `get_fail`\* [-45] string or array of strings

This condition makes an HTTP GET request to the specified URLs and evaluates to true if any status code is not 200. If the URL begins with `/`, then `https://{{host}}` is prepended to the URL, allowing you to omit the scheme and hostname.

##### Local variables

- `err` description of first error
- `status` number or array of numbers that correspond with the URLs

#### `if`\* [-50] table or array of tables

This condition allows you to compare different values.

- Compare variable to string: `if = { service = "ssh" }`
- Compare string variables: `if = { service = "{{my_service}}" }`
- Compare variable to number: `if = { num = 42 }` or `if = { num = "42" }`
- Compare number variables: `if = { num = "{{var}}" }`
- Greater/less than: `if = { num = ">90" }` or `if = { num = "<={{var}}" }`
- Array contains value: `if = { arr = "{{var}}" }`
- Array does not contain value: `if = { "!arr" = "{{var}}" }`
- Index array: `if = { "arr_0" = "{{var}}" }`
- Length of array: `if = { "#arr" = 0 }`
- Variable is any: `if = { port = [ 80, 443 ] }`

```toml
[monitor.if_and]
# ...
if = { a = 42, b = "Hello world" }
notify = { title = "a = 42 AND b = 'Hello world'" }

[monitor.if_or]
# ...
if = [{ a = 42 }, { b = "Hello world" }]
notify = { title = "a = 42 OR b = 'Hello world'" }

[task.if_xor]
notify = { title = "a = 42 XOR b = 'Hello world'" }
[monitor.if_xor]
# ...
[[monitor.if_xor.actions]]
if = { a = 42, "!b" = "Hello world" }
call = "if_xor"
[[monitor.if_xor.actions]]
if = { "!a" = 42, b = "Hello world" }
call = "if_xor"
```

#### `threshold`\* [-90] string

This condition is true if every preceding condition has been true at least `n` times within `d` duration. The format of this key is `"n/d"`.

```toml
[monitor.server_errors]
log = "/var/log/server/error.log"
threshold = "3/1m"
notify = { title = "Three server errors occured within one minute!" }
```

### Actions

Actions are run when an event fires and all conditions are true.

#### `exec` string or array of strings

This action spawns a child process. If this key is a string, it's passed as an argument to `sh -c` (\*nix) or `cmd /C` (Windows)\*, and variables are passed to the child through the environment. If this key is an array, the first item is the binary, and the remaining items are passed as arguments; variables can be passed to the child as arguments via templates.

> :information_source: Note: Processes are assumed to be short-lived; they will not be killed when Ramon exits.

#### `notify`\* table or string

This action sends a notification via email, PushBullet, ... TODO

#### `add`\* table

This action adds the specified value to each variable.

#### `set`\* table

This action sets variables.

```toml
[monitor.abc]
every = "2d"
set = { a = 42 }
[[monitor.abc.actions]]
set = { a = "{{ a * 2 }}", b = "Hello, world" }
[[monitor.abc.actions]]
if = { a = 84 }
set = { c = "b equals {{b}}" }
```

#### `push` table

This action pushes values to arrays. You can set the capacity of the array by declaring a variable named `<array name>_cap`. When pushing to an array that is at capacity, the oldest value is overwritten with the pushed value.

```toml
[var]
arr = []
arr_cap = 2

[task.foo]
push = { arr = 42 }
```

#### `call`\* string or array of strings

This action calls the specified tasks.

## Notifications\*

## Variables

Global variables are set in the `var` table on the root.

```toml
[var]
str = "Hello, world"
num = 42
arr = [1, 2, "3"]

[task.print_vars]
exec = 'echo str = "$str", num = "$num", arr = "$arr"'
# str = Hello, world, num = 42, arr = [1, 2, "3"]
```

## Tasks\*

\* Not yet implemented
